import fs from 'node:fs/promises';
import path from 'node:path';

import { parse } from '@babel/parser';
import type { ParserPlugin } from '@babel/parser';
import generator from '@babel/generator';
import traverseModule, { type NodePath } from '@babel/traverse';
import * as t from '@babel/types';
import fg from 'fast-glob';
import { unified } from 'unified';
import rehypeParse from 'rehype-parse';
import rehypeStringify from 'rehype-stringify';
import { visit } from 'unist-util-visit';
import type { Element, ElementContent, Properties, Root } from 'hast';

export type FixCategory = 'perf' | 'a11y' | 'seo';

export interface FixOptions {
  siteUrl: string;
  categories: FixCategory[];
  dryRun?: boolean;
  cwd?: string;
}

export interface FixDetail {
  file: string;
  actions: string[];
}

export interface FixExecutionResult {
  filesChanged: number;
  fixesApplied: string[];
  details: FixDetail[];
  wordpressPluginPath?: string;
}

export interface WordPressPluginOptions {
  siteUrl: string;
  dryRun?: boolean;
  outputDir?: string;
}

interface TransformOutcome {
  code: string;
  actions: string[];
}

type GeneratorFunction = typeof import('@babel/generator')['default'];
type TraverseFunction = typeof import('@babel/traverse')['default'];

const generatorModule = generator as { default?: GeneratorFunction };
const traverseModuleNamespace = traverseModule as { default?: TraverseFunction };

const generateAst: GeneratorFunction =
  typeof generatorModule.default === 'function'
    ? generatorModule.default
    : (generator as unknown as GeneratorFunction);
const traverseAst: TraverseFunction =
  typeof traverseModuleNamespace.default === 'function'
    ? traverseModuleNamespace.default
    : (traverseModule as unknown as TraverseFunction);

const DEFAULT_PATTERNS = [
  '**/*.html',
  '**/*.htm',
  '**/*.js',
  '**/*.jsx',
  '**/*.ts',
  '**/*.tsx'
];

const DEFAULT_IGNORE = [
  'node_modules/**',
  'dist/**',
  'build/**',
  'out/**',
  '.next/**',
  'autositefix-report/**',
  '**/autositefix-fixes/**'
];

const BABEL_PLUGINS: ParserPlugin[] = [
  'jsx',
  'typescript',
  'classProperties',
  'decorators-legacy',
  'dynamicImport',
  'optionalChaining',
  'nullishCoalescingOperator'
];

export async function applyFixes(options: FixOptions): Promise<FixExecutionResult> {
  const cwd = path.resolve(options.cwd ?? process.cwd());
  const categories = options.categories.length
    ? new Set(options.categories)
    : new Set<FixCategory>(['perf', 'a11y', 'seo']);

  const files = await fg(DEFAULT_PATTERNS, { cwd, ignore: DEFAULT_IGNORE, dot: false });
  const details: FixDetail[] = [];
  const applied = new Set<string>();

  for (const file of files) {
    const absolute = path.join(cwd, file);
    const original = await fs.readFile(absolute, 'utf8');

    if (original.includes('autositefix:ignore')) {
      continue;
    }

    let transformed: TransformOutcome | undefined;

    if (isHtmlFile(file)) {
      transformed = await transformHtml(original, categories, options.siteUrl);
    } else if (isJsLikeFile(file)) {
      transformed = transformJsx(original, categories, options.siteUrl);
    }

    if (!transformed || transformed.code === original) {
      continue;
    }

    if (!options.dryRun) {
      await fs.writeFile(absolute, transformed.code, 'utf8');
    }

    details.push({ file, actions: transformed.actions });
    transformed.actions.forEach((action) => applied.add(action));
  }

  return {
    filesChanged: details.length,
    fixesApplied: Array.from(applied),
    details
  };
}

export async function generateWordPressPlugin(
  options: WordPressPluginOptions
): Promise<FixExecutionResult> {
  const cwd = path.resolve(options.outputDir ?? process.cwd());
  const pluginDir = path.join(cwd, 'wp-content', 'plugins', 'autositefix-fixes');
  const pluginFile = path.join(pluginDir, 'autositefix-fixes.php');
  const readmeFile = path.join(pluginDir, 'README.md');

  const pluginHeader = `<?php
/**
 * Plugin Name: AutoSiteFix Fixes
 * Description: Automated performance, accessibility, and SEO optimizations generated by AutoSiteFix.
 * Version: 0.1.0
 */

if (!defined('ABSPATH')) {
    exit;
}

add_action('wp_head', function () {
    $canonical = esc_url('${options.siteUrl}');
    $origin = esc_url('${getOrigin(options.siteUrl)}');
    echo '<link rel="preconnect" href="' . $origin . '" crossorigin />' . "\n";
    echo '<link rel="canonical" href="' . $canonical . '" />' . "\n";
    echo '<meta name="description" content="Automated improvements provided by AutoSiteFix." />' . "\n";
});

add_filter('the_content', function ($content) {
    if (strpos($content, 'autositefix:ignore') !== false) {
        return $content;
    }

    $content = preg_replace_callback('/<img\\b[^>]*>/i', function ($matches) {
        $tag = $matches[0];
        if (stripos($tag, 'loading=') === false) {
            $tag = preg_replace('/<img\\b/i', '<img loading="lazy"', $tag, 1);
        }
        if (stripos($tag, 'decoding=') === false) {
            $tag = preg_replace('/<img\\b/i', '<img decoding="async"', $tag, 1);
        }
        return $tag;
    }, $content);

    return $content;
});
`;

  const pluginReadme = `# AutoSiteFix Fixes Plugin

This plugin was generated automatically by AutoSiteFix. It injects canonical, preconnect, and meta description tags into the \`wp_head\` hook and ensures images rendered via \`the_content\` use \`loading="lazy"\` and \`decoding="async"\` attributes.
`;

  if (!options.dryRun) {
    await fs.mkdir(pluginDir, { recursive: true });
    await fs.writeFile(pluginFile, pluginHeader, 'utf8');
    await fs.writeFile(readmeFile, pluginReadme, 'utf8');
  }

  return {
    filesChanged: options.dryRun ? 0 : 2,
    fixesApplied: ['Generated WordPress micro-plugin'],
    details: options.dryRun
      ? []
      : [
          { file: path.relative(process.cwd(), pluginFile), actions: ['Created plugin entry point'] },
          { file: path.relative(process.cwd(), readmeFile), actions: ['Documented WordPress plugin usage'] }
        ],
    wordpressPluginPath: pluginDir
  };
}

function isHtmlFile(file: string): boolean {
  return /\.(html?|php)$/i.test(file);
}

function isJsLikeFile(file: string): boolean {
  return /\.(t|j)sx?$/i.test(file);
}

async function transformHtml(
  source: string,
  categories: Set<FixCategory>,
  siteUrl: string
): Promise<TransformOutcome | undefined> {
  const processor = unified().use(rehypeParse, { fragment: false }).use(rehypeStringify, {
    allowDangerousHtml: true
  });

  const tree = processor.parse(source) as Root;
  const actions = new Set<string>();

  visit(tree, 'element', (node: Element) => {
    if (node.tagName === 'img') {
      ensureHtmlImageAttributes(node, categories, actions);
    }

    if (node.tagName === 'script') {
      ensureHtmlScriptDefer(node, categories, actions);
    }

    if (node.tagName === 'head') {
      ensureHtmlHead(node, categories, siteUrl, actions);
    }
  });

  const transformed = (await processor.run(tree)) as Root;
  const code = processor.stringify(transformed).toString();

  if (!actions.size) {
    return undefined;
  }

  if (code === source) {
    return undefined;
  }

  return { code, actions: Array.from(actions) };
}

function ensureHtmlImageAttributes(
  node: Element,
  categories: Set<FixCategory>,
  actions: Set<string>
): void {
  if (!categories.has('perf') && !categories.has('a11y')) {
    return;
  }

  node.properties ??= {};
  if (!('loading' in node.properties)) {
    node.properties.loading = 'lazy';
    actions.add('Added loading="lazy" to HTML images');
  }
  if (!('decoding' in node.properties)) {
    node.properties.decoding = 'async';
    actions.add('Added decoding="async" to HTML images');
  }
}

function ensureHtmlScriptDefer(
  node: Element,
  categories: Set<FixCategory>,
  actions: Set<string>
): void {
  if (!categories.has('perf')) {
    return;
  }

  node.properties ??= {};
  const hasSrc = typeof node.properties.src === 'string' && node.properties.src.length > 0;
  const isModule = node.properties.type === 'module';
  const hasInlineCode = Array.isArray(node.children) && node.children.length > 0;
  const alreadyAsync = 'async' in node.properties || 'defer' in node.properties;

  if (hasSrc && !isModule && !hasInlineCode && !alreadyAsync) {
    node.properties.defer = true;
    actions.add('Converted blocking script to defer');
  }
}

function ensureHtmlHead(
  node: Element,
  categories: Set<FixCategory>,
  siteUrl: string,
  actions: Set<string>
): void {
  const origin = getOrigin(siteUrl);

  if (categories.has('perf') && !hasHeadElement(node, 'link', 'rel', 'preconnect')) {
    node.children = node.children ?? [];
    node.children.push(
      createHastElement('link', {
        rel: ['preconnect'],
        href: origin,
        crossOrigin: ''
      })
    );
    actions.add('Inserted preconnect link');
  }

  if (categories.has('seo') && !hasHeadElement(node, 'link', 'rel', 'canonical')) {
    node.children = node.children ?? [];
    node.children.push(createHastElement('link', {
      rel: 'canonical',
      href: siteUrl
    }));
    actions.add('Inserted canonical link');
  }

  if (categories.has('seo') && !hasHeadElement(node, 'meta', 'name', 'description')) {
    node.children = node.children ?? [];
    node.children.push(createHastElement('meta', {
      name: 'description',
      content: 'Automated improvements provided by AutoSiteFix.'
    }));
    actions.add('Inserted meta description');
  }
}

function hasHeadElement(
  node: Element,
  tagName: string,
  attribute: string,
  value: string
): boolean {
  return (node.children ?? []).some((child: ElementContent): boolean => {
    if (child.type !== 'element') {
      return false;
    }
    const element = child as Element;
    if (element.tagName !== tagName) {
      return false;
    }
    const props = element.properties ?? {};
    const propValue = props[attribute];
    if (Array.isArray(propValue)) {
      return propValue.some((entry) => String(entry).toLowerCase() === value.toLowerCase());
    }
    if (typeof propValue === 'string') {
      return propValue.toLowerCase() === value.toLowerCase();
    }
    return false;
  });
}

function createHastElement(tagName: string, properties: Properties): Element {
  return {
    type: 'element',
    tagName,
    properties,
    children: []
  };
}

function transformJsx(
  source: string,
  categories: Set<FixCategory>,
  siteUrl: string
): TransformOutcome | undefined {
  const ast = parse(source, {
    sourceType: 'module',
    plugins: BABEL_PLUGINS
  });

  const actions = new Set<string>();
  const headElements: NodePath<t.JSXElement>[] = [];

  traverseAst(ast, {
    JSXElement(path: NodePath<t.JSXElement>) {
      const opening = path.node.openingElement;
      const tagName = getJsxTagName(opening.name);
      if (!tagName) {
        return;
      }

      if (tagName === 'img') {
        ensureJsxImageAttributes(opening, categories, actions);
      }

      if (tagName === 'script') {
        ensureJsxScriptAttributes(path, categories, actions);
      }

      if (tagName === 'Head' || tagName === 'head') {
        headElements.push(path);
      }
    }
  });

  if (headElements.length > 0) {
    headElements.forEach((headPath) => {
      ensureJsxHeadElements(headPath, categories, siteUrl, actions);
    });
  }

  if (!actions.size) {
    return undefined;
  }

  const output = generateAst(ast, { retainLines: true }, source);
  return { code: output.code, actions: Array.from(actions) };
}

function ensureJsxImageAttributes(
  opening: t.JSXOpeningElement,
  categories: Set<FixCategory>,
  actions: Set<string>
): void {
  if (!categories.has('perf') && !categories.has('a11y')) {
    return;
  }

  if (!hasJsxAttribute(opening, 'loading')) {
    opening.attributes.push(
      t.jsxAttribute(t.jsxIdentifier('loading'), t.stringLiteral('lazy'))
    );
    actions.add('Added loading="lazy" to JSX images');
  }

  if (!hasJsxAttribute(opening, 'decoding')) {
    opening.attributes.push(
      t.jsxAttribute(t.jsxIdentifier('decoding'), t.stringLiteral('async'))
    );
    actions.add('Added decoding="async" to JSX images');
  }
}

function ensureJsxScriptAttributes(
  path: NodePath<t.JSXElement>,
  categories: Set<FixCategory>,
  actions: Set<string>
): void {
  if (!categories.has('perf')) {
    return;
  }

  const opening = path.node.openingElement;
  const srcAttr = getJsxAttribute(opening, 'src');
  const hasSrc = srcAttr && t.isStringLiteral(srcAttr.value);
  const hasInlineChildren = path.node.children.some((child) => {
    if (t.isJSXText(child)) {
      return child.value.trim().length > 0;
    }
    return !t.isJSXText(child);
  });
  const typeAttr = getJsxAttribute(opening, 'type');
  const isModule = Boolean(
    typeAttr &&
      typeAttr.value &&
      t.isStringLiteral(typeAttr.value) &&
      typeAttr.value.value === 'module'
  );
  const alreadyAsync = hasJsxAttribute(opening, 'async') || hasJsxAttribute(opening, 'defer');

  if (hasSrc && !hasInlineChildren && !alreadyAsync && !isModule) {
    opening.attributes.push(t.jsxAttribute(t.jsxIdentifier('defer'), null));
    actions.add('Converted JSX script to defer');
  }
}

function ensureJsxHeadElements(
  path: NodePath<t.JSXElement>,
  categories: Set<FixCategory>,
  siteUrl: string,
  actions: Set<string>
): void {
  const origin = getOrigin(siteUrl);
  const children = path.node.children;

  if (categories.has('perf') && !jsxHeadContains(children, 'link', 'rel', 'preconnect')) {
    children.push(
      createJsxElement('link', {
        rel: 'preconnect',
        href: origin,
        crossorigin: ''
      })
    );
    actions.add('Inserted JSX preconnect link');
  }

  if (categories.has('seo') && !jsxHeadContains(children, 'link', 'rel', 'canonical')) {
    children.push(
      createJsxElement('link', {
        rel: 'canonical',
        href: siteUrl
      })
    );
    actions.add('Inserted JSX canonical link');
  }

  if (categories.has('seo') && !jsxHeadContains(children, 'meta', 'name', 'description')) {
    children.push(
      createJsxElement('meta', {
        name: 'description',
        content: 'Automated improvements provided by AutoSiteFix.'
      })
    );
    actions.add('Inserted JSX meta description');
  }
}

function jsxHeadContains(
  children: (t.JSXText | t.JSXExpressionContainer | t.JSXSpreadChild | t.JSXElement | t.JSXFragment)[],
  tagName: string,
  attributeName: string,
  attributeValue: string
): boolean {
  return children.some((child) => {
    if (!t.isJSXElement(child)) {
      return false;
    }

    const name = getJsxTagName(child.openingElement.name);
    if (name !== tagName) {
      return false;
    }

    const attr = getJsxAttribute(child.openingElement, attributeName);
    return (
      attr &&
      attr.value !== null &&
      t.isStringLiteral(attr.value) &&
      attr.value.value === attributeValue
    );
  });
}

function createJsxElement(
  tagName: string,
  attributes: Record<string, string>
): t.JSXElement {
  const opening = t.jsxOpeningElement(
    t.jsxIdentifier(tagName),
    Object.entries(attributes).map(([key, value]) =>
      value === ''
        ? t.jsxAttribute(t.jsxIdentifier(key), null)
        : t.jsxAttribute(t.jsxIdentifier(key), t.stringLiteral(value))
    ),
    true
  );
  const closing = t.jsxClosingElement(t.jsxIdentifier(tagName));
  return t.jsxElement(opening, closing, [], true);
}

function hasJsxAttribute(opening: t.JSXOpeningElement, name: string): boolean {
  return opening.attributes.some(
    (attr) => t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name) && attr.name.name === name
  );
}

function getJsxAttribute(
  opening: t.JSXOpeningElement,
  name: string
): t.JSXAttribute | undefined {
  return opening.attributes.find(
    (attr): attr is t.JSXAttribute => t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name) && attr.name.name === name
  );
}

function getJsxTagName(name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName): string | undefined {
  if (t.isJSXIdentifier(name)) {
    return name.name;
  }
  if (t.isJSXMemberExpression(name)) {
    return getJsxTagName(name.property);
  }
  return undefined;
}

function getOrigin(url: string): string {
  try {
    const parsed = new URL(url);
    return `${parsed.protocol}//${parsed.host}`;
  } catch {
    return url;
  }
}

export const __testing = {
  transformHtml,
  transformJsx,
  ensureHtmlImageAttributes,
  ensureJsxImageAttributes
};
